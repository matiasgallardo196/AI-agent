# Technical Documentation of the AI Agent

## 1. Conceptual Design

### 1.1 Assistant Flow Map

**Scenario 1: Search Products**

```
User: "I want to see pants"
   ⯆
POST /message { message: "I want to see pants" }
   ⯆
OpenAI detects intention: get_products
   ⯆
GET /products?q=pants
   ⯆
Returns product list
```

**Scenario 2: Create Cart**

```
User: "Add 2 Green Pants Size XXL to cart"
   ⯆
POST /message { message: "Add 2 Green Pants Size XXL to cart" }
   ⯆
OpenAI detects intention: create_cart
   ⯆
POST /carts
Body: { items: [{ product_id: 1, qty: 2 }] }
```

**Scenario 3: Modify Cart**

```
User: "Better put just one"
   ⯆
POST /message { message: "Better put just one" }
   ⯆
OpenAI detects intention: update_cart
   ⯆
PATCH /carts/:id
Body: { items: [{ product_id: 1, qty: 1 }] }
```

### 1.2 High-Level Architecture

```
┌────────────────────────────┐
│      End User              │
└────────────┬───────────────┘
             ▼
┌──────────────────────────────────────────────┐
│ Chat Web (React) / WhatsApp (Twilio API)     │
│ - Captures user input                        │
│ - Sends messages to backend via HTTP         │
└────────────┬─────────────────────────────────┘
             │ POST /message
             ▼
┌────────────────────────────┐
│ NestJS Backend             │
│ - Detects intention        │
│ - Executes REST logic      │
└────────────┬───────────────┘
             ▼
┌────────────────────────────┐
│ OpenAI (Embeddings + Chat) │
└────────────┬───────────────┘
             ▼
┌─────────────────────────────────────────┐
│PostgreSQL (Supabase + pgvector)+ Prisma │
└─────────────────────────────────────────┘
```

### 1.3 Design Viability

- Modular architecture (NestJS with separate services)
- Use of standard HTTP, ideal for REST integrations
- PostgreSQL allows scalability and complex queries
- Supabase facilitates the use of managed PostgreSQL with extensions like `pgvector`, fundamental for semantic searches with embeddings
- Prisma simplifies database access and migrations
- Clean interface: a single `/message` endpoint handles everything

### 1.4 Suggested Metrics

- **Conversion rate:** product queries / carts created
- **Average response time** of the AI agent (from message to response)
- **Stock errors:** percentage of requests with insufficient stock

---

## 2. Execution Instructions

### 2.1 Requirements

- Node.js 18+
- PostgreSQL (Supabase + pgvector)
- OpenAI API Key

### 2.2 Environment Setup

```bash
# 1. Environment variables
cp backend/.env.example backend/.env
cp frontend/.env.example frontend/.env

# 2. Configure .env
# backend/.env
DATABASE_URL=postgresql://postgres:[YOUR_PASSWORD]@aws-0-us-east-1.pooler.supabase.com:5432/postgres
OPENAI_API_KEY=sk-...
PORT=3001

# frontend/.env
NEXT_PUBLIC_API_BASE_URL=http://localhost:3001

# 3. Install dependencies and prepare data
cd backend
npm install
npx prisma generate
npm run setup   # Creates database, loads products, generates embeddings

# 4. Run frontend and backend (in separate terminals)
cd backend && npm run start:dev
cd frontend && npm install && npm run dev
```

---

### 2.3 Database Schema

The database was modeled with Prisma ORM and hosted on Supabase to take advantage of extensions like `pgvector`.

| Table        | Key Fields                                                                     |
| ------------ | ------------------------------------------------------------------------------ |
| `products`   | `id`, `name`, `description`, `price`, `stock`, `embedding` _(optional vector)_ |
| `carts`      | `id`, `created_at`, `updated_at`                                               |
| `cart_items` | `id`, `cart_id` (FK), `product_id` (FK), `qty`                                 |

> Indexes added to `name` and `description` for more efficient searches.  
> The `embedding` field (vector) was included in the `Product` model to enable semantic searches through embeddings generated by OpenAI. This field requires the `pgvector` extension, available in Supabase.
> Relationships are defined with `@relation` and columns are mapped to `snake_case` via `@@map` to align with conventional SQL style.

## 3. API Documentation

### GET /products

- **Description:** Lists products, allows searching with `?q=`.
- **Query parameters:** `q` (optional, string)
- **Response (200):**

```json
[{ "id": 1, "name": "Green Pants", "price": 25.5, "stock": 12 }]
```

- **Errors:** 404 Not Found 500 internal error

---

### GET /products/:id

- **Description:** Returns a product by ID
- **Path parameters:** `id` (number)
- **Response (200):**

```json
{ "id": 1, "name": "Green Pants", "price": 25.5, "stock": 12 }
```

- **Errors:** 404 if not exists

---

### POST /carts

- **Description:** Creates cart with products
- **Body:**

```json
{ "items": [{ "product_id": 1, "qty": 2 }] }
```

- **Response (201):** created cart
- **Errors:** 400 (empty), 404 (product not exists), 422 (no stock)

---

### PATCH /carts/\:id

- **Description:** Modifies an existing cart
- **Path parameters:** `id` of the cart
- **Body:** same as POST
- **Response (200):** updated cart
- **Errors:** 400, 404, 422 (insufficient stock)

---

> Online demo:
>
> - Frontend: [https://desafio-tecnico-cse-laburen-com.vercel.app/](https://desafio-tecnico-cse-laburen-com.vercel.app/)
> - Backend: [https://desafio-tecnico-cse-laburen-com.onrender.com](https://desafio-tecnico-cse-laburen-com.onrender.com)
> - WhatsApp (Twilio sandbox): send the message **join feed-individual** to the number **+1 415 523 8886** from your WhatsApp to join. Then you can interact with the agent normally (for example: "I want to see pants").
